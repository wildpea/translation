backbone.js

	Backbone.js，是一个web应用架构，它提供支持key-value绑定和自定义事件到模型（modesl）、有着可枚举的丰富API函数的集合（collections）、定义事件绑定的视图（views），并通过REST风格的JSON接口连接你已有的API。
	本项目托管在GitHub上，包括带注释的源代码，在线调试，应用案例，指南列表，和一个使用了backbone的真实项目的长列表。Backbone在MIT软件许可下使用。
	你可以在GitHub页面上、Freenode IRC的#document标签下、在Google Group中报告、在wiki中增加页面，或给@documnetcloud发tweets，来报告bug以及讨论特性。
	Backbone是Documentloud的一个开源组件。
		
	下载&依赖(右击，选择“保存为”)
	Backbone仅重度依赖于Underscore.js(>1.3.1)。要使用RESTful、历史支持，需要用到Backbone.Router，DOM操作需要Backbone.View，包括json2.js，和jQuery(>1.4.2)或者Zepto。

简介
	在构建需要大量使用JavaScript的web应用时，你需要注意的头等大事是停止把数据绑定到DOM上。经常会导致使用大量jQuery选择器和回调函数，使得程序看起来一团糟，并在HTML UI、你到Javascript逻辑和服务器数据库之间保存保持同步而发疯。对于客户端富应用而言，一个更结构化到解决方案通常很有帮助。
	使用Backbone，你把数据存在Models中，它可以被创建、验证、销毁、把数据保存到服务器端。当UI交互导致Models中到属性发生变化时，模型触发一个'change'事件；所有显示模型状态的Views都可以监听到这一事件，并能据此作出反应，用新数据重新渲染。在一个完整的Backbone app中，你不需要写胶合代码查看DOM，并通过id来查找元素，并手工更新HTML——当模型发生变化时，视图会自己更新自己。
	如果你是新手，并且不是确切的知道Backbone到底是做什么的，可以从 基于Backbone做的项目列表 开始。
	下面的大部分代码都是可以运行的，单击play按钮来执行它们。

升级到0.9
	Backbone 0.9版被认为是即将发布的1.0版的候选者。一些API发生了改变，这儿有一份修改日志，一些新特性占优势，有几点改变你需要注意：
	·如果你曾在Backbone View中手动设置过this.el作为一个特定的DOM元素，你可以用setElement替代。
	·生成和销毁模型现在是乐观的（------------）。如果你需要让前面的等待服务器回应的行为知道成功，可以传{wait:true}。你也可以通过传{wait:true}来保存调用。
	·如果你曾写过相当数量的$(view.el)，现在为该jQuery对象提供缓存引用：$el
	·如果你升级，请保证Underscore.js已经至少升级到1.3.1
	·传参数{slilent:true}之后，将数据置为初始值，model.set将不触发change事件。同样的，属性安静的改变后，change:attribute事件将在下个change事件发生时调用。
	·介于vie.$(selector)现在等同于view.$el.find(selector)，而不是$(selector, view.el)，它将不再支持HTML字符串或者DOM元素作为selector参数。

Backbone Events
	Events是一个模块，可被嵌入任何对象中，为对象提供绑定自定义事件的能力。Eents不需要在使用前定义，可以传递参数。例：
	var object = {};
	_.extend(object, Backbone.Events);
	object.on('alert', function(msg){
		alert('Triggered' + msg);
	});
	object.trigger('alert', 'an event');
	例如，这样可以为你的应用的不同部分提供便利的事件分发：var dispatcher = _.clone(Backbone.Events);

on	object.on(event, callback, [context])	Alias:bind
	绑定一个callback至一个对象。只要event被触发，将执行callback函数。如果你在一个页面有大量不同的事件，惯例是用冒号分割来命名：'poll:start'，或者'change:selection'。还可以通过空格隔开，同时绑定多个事件：
	book.on('change:title change:author');
	要给this变量提供上下文环境context，通过给第三个可选参数：model.on('change', this.render, this)
	任何事件发生的时候，绑定的特殊的'all'事件都将会被触发，这时，触发的事件名称为第一个参数。例如，从一个对象中触发所有事件到另一个对象中去：
	proxy.on('all', function(eventName){
		object.trigger(eventName);
	});	

off	object.off([event], [callback], [context])  Alias: unbind
	从对象中移除先前绑定的callback函数。如果没有指定context，当前回调函数将在所有上下文中被移除。如果没有指定回调函数，当前event的所有回调函数将会被移除。如果没有指定events，改对象的所有events的回调函数将会被移除。
	//仅仅移除'onChange'回调函数
	object.off('change', onChange);
	//移除所有'change'回调函数
	object.off('change');
	//移除所有events的'onChange'回调函数
	object.off(null, onChange);
	//移除'context'下所有events的所有回调函数
	object.off(null, null, context);
	//移除object的所有回调函数
	object.off();

trigger	object.trigger(event, [*args])
	触发指定event的所有回调函数，或者由空格分隔的多项event。第二项参数将会传递给回调函数。
	
	
	
Backbone.Model
	Models是任何Javascript应用的核心，它包括交互数据，以及相应的大量逻辑：转换、验证、计算属性，以及访问控制。你在你自己的特定域中扩展Backbone.Model，Model将会为你提供一系列基础函数来管理变化。
	下面是一个虚构的例子，但它展示了定义model，包括：自定义函数、设定属性值、触发绑定在某个属性上的事件。在这段代码执行一次后，你的浏览器控制台中将可以获取到sidebar这个对象，你可以尝试一下。
	var Sidebar = Backbone.Model.extend({
		promptColor: function(){
			var cssColor = promp('Please enter a CSS color:');
			this.set({color: cssColor});
		}
	});
	window.sidebar = new Sidebar;
	sidebar.on('change:color', function(model, color){
		$('#sidebar').css({background: color});
	});
	sidebar.set({color: 'white'});
	sidebar.prompColor();
	
Extend	Backbone.Model.extend(properties, [classProperties])
	要创建你自己的Model类，你只需要扩展Backbone.Model，
	
	
	
	
	
	
	
	
	
	
	



