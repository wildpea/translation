Meteor 0.5.4


Meteor API
	你的Javascript代码可以同时在两个环境下运行：客户端（浏览器），服务器端（服务器上的Node.js容器）。在本API文档中，如果该函数只能在客户端，或只能在服务器端，或可以在任何地方运行，我们会指出来。


（一）Meteor Core —— Meteor 核心、

Meteor.isClient													Anywhere
	布尔值。如果当前在客户端环境中，为true。
	
Meteor.isServer													Anywhere
	布尔值。如果当前在服务器端环境中，为true。
	
Meteor.startup(func)											Anywhere
	当客户端或服务器端启动的时候，运行代码。
		参数
			func	Function
			在开始时运行的函数
	在服务器端，该函数会在服务器进程启动完成后立即运行。在客户端，该函数会在DOM就绪，.html文件中的任意<body>模板显示在屏幕上之后，立即运行。
		//服务器端启动时，如果数据库为空，则初始化数据
		if (Meteor.isServer) {
			Meteor.startup(function () {
				if (Rooms.find().count() == 0) {
					Rooms.insert({name: "Initial room"});
				}
			});
		}
	
Meteor.absoluteUrl([path], [options])							Anywhere
	为应用生成一个绝对URL。服务器端读取环境变量ROOT_URL来决定在那里运行。在使用meteor deploy部署apps时，自动获取。但是在使用meteor bundle时，需要提供。
		参数
			path				String
			相对root URL的路径。不要包括开始的"/"
		可选项
			secure				Boolean
			创建HTTPS URL
			replacesLocalhost	Boolean
			将localhost替换成127.0.0.1。在服务器端不任务localhost是域名的情况下会用到
			rootUrl				String
			在服务器端覆盖默认的ROOT_URL。例如："http://foo.example.com"
			
Meteor.settings													Server
	Meteor.settings包含使用meteor run或者meteor delopy命令时，使用--options时可用的所有与部署相关的选项。Meteor.settings将是你文件中定义的JSON对象。否则，Meteor.settings为空对象。
	
	
（二）Publish and subscribe - 发布和订阅
这些函数控制了Meteor服务器端如何发布记录集合，以及客户端如何订阅这些集合的。

Meteor.publish(name, func)
	发布一个记录集。
		参数
			name	String
			属性集的名字。如果为null，该集合没有名字，记录将自动发送到所有连接的客户端。
			func	Function
			每次客户端订阅时，服务器端调用的函数。在该函数内部，this指向发布对象，见下面描述。如果客户端订阅时传递了参数，该函数调用时使用同样的参数。
	要发布记录到客户端，在服务器端调用Meteor.publish函数，传递两个参数：记录集的名字，以及每次客户端订阅该名字时Meteor会调用的发布函数。
	发布函数可以返回一个Collection.Cursor，如果Meteor要发布该指针指向的文档。
		//服务器：发布rooms集合，去掉密码信息
		Meteor.publish("rooms", function () {
			return Rooms.find({}, {fields: {secretInfo: 0}});
		});
		//...如果登录用户是admin，则在rooms中发布密码信息
		//如果客户端订阅了两个流，集合将合并到Rooms 集合的一个文档中
		Meteor.publish("adminSecretInfo", function () {
			return Rooms.find({admin: this.userId}, {fields: {secretInfo: 1}});
		});
	另外，发布函数可以set和unset客户端中单独的集合属性。这些函数由发布函数中的this提供。
	特别的，如果使用observe来观察数据库中的变化，确保在observe回调函数中调用this.flush。更新数据库的函数，在observe回调函数返回时，被认为完成了。
	例：
		//服务器：发布当前集合的大小
		Meteor.publish("counts-by-room", function () {
			var self = this;
			var uuid = Meteor.uuid();
			var count = 0;
			
			var handle = Messages.find({roomId: roomId}).observe({
				added: function (doc, idx) {
					count++;
					self.set("counts", uuid, {roomId: roomId, count: count});
					self.flush();
				},
				removed: function (doc, idx) {
					count--;
					self.set("couont", uuid, {roomId: roomId, count: count});
					self.flush();
				}
				//不关心移动或变化
			});
			//Observe仅在初始化added回调函数运行后返回。现标记subscription为就绪
			self.complete();
			self.flush();
			//客户端停止订阅的时候，停止观察
			self.onStop(function () {
				handle.stop();
			});
		});
		
		//客户端：声明实例化一个集合对象count
		Counts = new Meteor.Collections("counts");
		
		//客户端：自动订阅当前房间数
		Meteor.autosubscribe(function () {
			Meteor.subscribe("counts-by-room", Session.get("roomId"));
		});
		
		//客户端：使用新集合
		console.log("Corrent room has " + Counts.findOne().count + " mesages.");
	
	提示：如果你在调用Meteor.publish时，包含了autopublish包，Meteor将会产生一条警告。发布函数仍然会工作。
	
this.userId														Server
	在发布函数中获取。当前登录用户的id，如果用户未登录，返回null。
	这是一个常量。但如果登录用户切换了，发布函数会以新值重新运行。
	
this.set(collection, id, attributes)							Server
	在发布函数内部调用。设置属性。
		参数
			collection	String
			要设置的集合的名字
			id			String
			要设置的文档的id
			attributes	Object
			属性键值对

this.unset(collection, id, keys)								Server
	在发布函数内部调用。重置属性。
		参数
			collection	String
			要设置的集合的名字
			id			String
			要设置的文档的id
			keys		Array
			属性键数组
			
this.complete()													Server
	在发布函数内部调用。标记当前订阅已完成（初始化属性设置完成）。
	
this.flush()													Server
	在发布函数内部调用。发送所有set，unset，complete函数到客户端。
	
this.onStop(func)												Server
	在发布函数内部调用。注册一个回调函数，当订阅终止时调用。
		参数
			func	Function
			回调函数
	如果在发布句柄中调用observe，这将终止observes。
	
this.stop()														Server
	在发布函数内部调用。终止客户端订阅。
	
Meteor.subscribe(name, [, arg1, arg2, ...] [, onComplete])		Client
	订阅一个记录集。返回一个句柄，该句柄提供stop()函数，可以停止订阅。
		参数
			name				String
			订阅的名字。与服务器端发布函数中的匹配
			arg1, arg2, ...		任意类型
			传递给服务器端发布函数的可选参数
			onComplete			Function
			如果最后一个参数是函数，则将在服务器标记订阅完成时调用。无参
	当订阅一个记录集时，将通知服务器发送记录到客户端。客户端将数据存储在本地Minimongo集合中，使用与set函数中的collection参数相同的名字。Meteor会将获取到的属性存入队列中，直到在客户端用Meteor.Collection声明对应的集合名。
		//在客户端声明集合存储之前也可以订阅（可收到数据）。
		//假设"allplayers"从服务器端"players"集合中发布数据
		Meteor.subscribe("allplayers");
		//客户端将获取到的players记录存入队列中，直到...
		Players = new Meteor.Collection("players");
	如果不止一个订阅发送同一属性（相同集合名，相同文档ID，相同属性名）的值相冲突，客户端的值将会是客户端第一次发起订阅的值（即使可能不是第一个发送回客户端的值）。
	如果文档中所有属性被删除了，Meteor将会删除该文档（现在是空的了）。如果想要发布空文档，使用一个替代属性：
		clicks.insert({existes: true});
		
Meteor.autosubscribe(func)										Client
	自动建立并销毁订阅
		参数
			func	Function
			一个反应式函数，通过Meteor.subscribe函数建立订阅。当依赖发送变化时，自动重新运行。
	func会立即运行，而运行的时候，订阅的记录（通过Meteor.subscribe）和使用到的数据（调用Session.get和collection.find）将会保持。
	只要使用到的数据发生改变，订阅将会被取消，func重新运行来建立新的订阅。meteor.autosubscribe将自动停止旧的订阅。在Meteor.autosubscribenebulizer，不需要调用订阅的stop函数。
	例：
		//在当前房间内订阅消息。只要当前房间发生改变，自动更新订阅
		Meteor.autosubscribe(function () {
			Meteor.subscribe("chat", {root: Session.get("current-room")});
		});
		

（三）方法
方法，是可以在Meteor客户端中远程调用的函数。

Meteor.methods(methods)											Anywhere
	定义可被客户端通过网络调用的函数
		参数
			方法	object
			键值对，键为方法名，值为函数
	例：
		Meteor.methods({
			foo: function (arg1, arg2) {
				//.. do stuff ..
				if (you want to throw an error) {
					throw new Meteor.Error(404, "Can't find my pants");
				}
				return "some return value";
			},
			bar: function () {
				//.. do other stuff ..
				return "baz";
			}
		});
	Calling methods，在服务器端定义可被客户端调用函数。他们应该要返回值，或抛出异常。在方法调用内部，this绑定到方法调用对象，该对象提供：
		· isSimulation：布尔值，如果调用时stub，为true
		· unblock：调用的时候，允许客户端下一个方法开始运行
		· userId：当前用户的id
		· setUserId：函数，将当前客户端和一名用户联系起来
	Calling methods，在客户端定义stub函数，与服务器端方法保持一样的名字。如果不需要，可以不为methods定义stub函数。这种情况下，方法调用与其他系统中的远程调用一样，而你必须等到服务器端返回值。
	如果定义了stub函数，当客户端调用服务器端方法时，将通用会触发本身的stub函数。在客户端，stub函数的返回值被忽略。Stub函数运行是位了其边际效应：他们将会simulate服务器方法的结果，但不需要等待来回调用延迟。如果stub抛出异常，将会打印到控制台。
	你一直在使用方法，数据库基本函数（insert, update, remove）都是通过方法实现的。在客户端调用他们中的任意一个时，你将触发他们的stub版本来更新本地缓存，并发送同样的请求到服务器端。当服务器端响应时，客户端再使用真正从服务器端获取的数据更新本地缓存。
	
this.userId														Anywhere
	发起方法请求的当前用户id。如果用户未登录，则为null
	用户id是任意字符串————通常用户id都存储在数据库中。你可以通过setUserId函数来设置它。如果你在使用Meteor账户系统，then this is handled for you.
	
this.setUserId(userId)											Server
	设置登录用户
		参数
			userId		String or null
			该值应该再集合中通过userId返回
	调用该函数来在发起方法调用的连接中改变当前登录用户。它仅仅设置本连接将来调用方法时的userId值。传null注销连接。
	如果你使用内置的Meteor账户系统，它应该与Meteor.users集合中的_id属性相匹配。
	setUserId是无追溯的。它影响当前的方法调用和当前连接未来的调用。连接中任何先前的方法调用再发起时，仍然看到userId被改变了。
	
this.isSimulation												Anywhere
	在方法调用内部可获取。布尔值，如果当前调用是stub，为true。

this.unblock()													Server
	在方法调用内部调用。允许客户端随后的方法调用可在一个新的fiber中运行。
	在服务器端，某一客户端一次只能调用一个方法。第N+1个方法调用不会开始，知道第N个方法调用返回。然而，可以通过调用this.unblock来改变这个。它将允许第N+1个方法在新的fiber中运行。
	
new Meteor.Error(error, reason, details)						Anywhere
	该类标识着方法抛出的symbolic错误
		参数
			eorror	Number
			数字错误码，类似于HTTP返回码（如404，500）
			reason	String
			可选。简短的人类可阅读的错误总结，如"Not Found"
			details String
			可选。关于错误的更多信息，如堆栈跟踪信息的文字描述
	如果你希望从方法中返回一个错误，抛出异常。方法可以抛出任何类型的异常。但Meteor.Error是唯一会发送到客户端的错误。如果方法函数抛出其它类型的异常，将会发送到网络上：Meteor.Error(500, "Internal server error")。
	
Meteor.call(name, param1, param2, ... [, asyncCallback])		Anywhere
	传递任意数量的参数调用方法
		参数
			name					String
			要调用的方法名
			param1, param2, ...		JSON
			可选的方法参数
			asyncCallback			Function
			可选的回调函数。在方法完成后抛出异常或返回值后异步调用。如果未提供，可能的情况下方法同步运行（见下）。
	这是关于如何调用方法的。将在服务器端调用方法。如果有可用的stub，将同时在客户端同步执行。（同样参见Meteor.apply，它与Meteor.call一样，除了参数以数组方式传递，而非逗号间隔的参数，而你可以指定一些参数来控制方法如何执行）。
	如果在参数中的最好包含了一个回调函数（由于函数不能被序列化，它将不能传递到方法中），方法将会异步调用：它将不会返回任何特殊的值，也不会抛出异常。当方法完成的时候（可能在Meteor.call返回之前完成，也可能在之后），回调函数将会随着两个参数一起调用：error和result。如果抛出错误，error将是异常对象。否者，error将是undefined，返回的值（可能也是undefined）在result中。
		//同步调用
		Meteor.call('foo', 1, 2, function (error, result) {...});
	如果你不向服务器传递回调函数，方法调用将会被锁定，直到方法完成。最终将会返回方法的值，如果方法抛出异常则抛出异常。（如果发生远程错误，而不是Meteor.Error异常，可能是500服务器错误）。
		//同步调用
		var result = Meteor.call('foo', 1, 2);
	在客户端，如果没有传递回调函数，也没有定义stub，call将会返回undefined，而你没有途径可以获取到方法的返回值。这是因为客户端没有fibers，所以实际上也没有可能会阻塞方法的远程调用。
	最后，如果你在客户端的stub中调用另一个方法，另一个方法将不会执行（没有RPC会被触发，没有真正发生任何事情）。如果另一个方法也有一个stub，代表该方法的stub将会被执行。方法调用的返回值会是stub函数的返回值。客户端同步执行stub函数没有任何问题，这就是为什么客户端在方法内部，使用同步Meteor.call方法是可行的的原因。
	无论在客户端还是服务器端，Meteor通过方法跟踪数据库写操作，直到服务器的数据写到本地缓存中替代stub的数据之前，不会调用asyncCallback。有时，在方法返回值可用，和写操作可见之间存在延迟：例如，如果另一个方法在写入同一个文档，本地缓存不会马上更新，直到该方法完成。如果你希望服务器端返回值到达之后立刻处理，即使方法的写不可用，你可以在Meteor.apply中使用onResultReceived。
	
Meteor.apply(name, params [, options] [, asyncCallback])		Anywhere
	使用数组参数调用方法。
		参数
			name				String
			要调用的方法名
			params				Array
			方法参数
			asyncCallback		Function
			可选的回调函数；与Meteor.call中的一样
		可选参数
			wait				Boolean
			（仅用于客户端）如果为true，所有之前的方法都完成之前不会调用方法，而且在当前方法完成之前，不会调用任何其它方法。
			onResultReceived	Function
			（仅用于客户端）在服务器端返回错误或结果时（就像在asyncCallback中一样），立刻随着错误或结果调用。本地缓存可能还没有被方法结果改变。
	Meteor.apply就像Meteor.call一样，除了参数通过数组传递，而不是直接传递。你可以指定一些选项来决定客户端如何执行。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	