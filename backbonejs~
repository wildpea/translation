backbone.js

	Backbone.js，是一个web应用架构，它提供支持key-value绑定和自定义事件到模型（modesl）、有着可枚举的丰富API函数的集合（collections）、定义事件绑定的视图（views），并通过REST风格的JSON接口连接你已有的API。
	本项目托管在GitHub上，包括带注释的源代码，在线调试，应用案例，指南列表，和一个使用了backbone的真实项目的长列表。Backbone在MIT软件许可下使用。
	你可以在GitHub页面上、Freenode IRC的#document标签下、在Google Group中报告、在wiki中增加页面，或给@documnetcloud发tweets，来报告bug以及讨论特性。
	Backbone是Documentloud的一个开源组件。
		
	下载&依赖(右击，选择“保存为”)
	Backbone仅重度依赖于Underscore.js(>1.3.1)。要使用RESTful、历史支持，需要用到Backbone.Router，DOM操作需要Backbone.View，包括json2.js，和jQuery(>1.4.2)或者Zepto。

简介
	在构建需要大量使用JavaScript的web应用时，你需要注意的头等大事是停止把数据绑定到DOM上。经常会导致使用大量jQuery选择器和回调函数，使得程序看起来一团糟，并在HTML UI、你到Javascript逻辑和服务器数据库之间保存保持同步而发疯。对于客户端富应用而言，一个更结构化到解决方案通常很有帮助。
	使用Backbone，你把数据存在Models中，它可以被创建、验证、销毁、把数据保存到服务器端。当UI交互导致Models中到属性发生变化时，模型触发一个"change"事件；所有显示模型状态的Views都可以监听到这一事件，并能据此作出反应，用新数据重新渲染。在一个完整的Backbone app中，你不需要写胶合代码查看DOM，并通过id来查找元素，并手工更新HTML——当模型发生变化时，视图会自己更新自己。
	如果你是新手，并且不是确切的知道Backbone到底是做什么的，可以从 基于Backbone做的项目列表 开始。
	下面的大部分代码都是可以运行的，单击play按钮来执行它们。

升级到0.9
	Backbone 0.9版被认为是即将发布的1.0版的候选者。一些API发生了改变，这儿有一份修改日志，一些新特性占优势，有几点改变你需要注意：
	·如果你曾在Backbone View中手动设置过this.el作为一个特定的DOM元素，你可以用setElement替代。
	·生成和销毁模型现在是乐观的（------------）。如果你需要让前面的等待服务器回应的行为知道成功，可以传{wait:true}。你也可以通过传{wait:true}来保存调用。
	·如果你曾写过相当数量的$(view.el)，现在为该jQuery对象提供缓存引用：$el
	·如果你升级，请保证Underscore.js已经至少升级到1.3.1
	·传参数{slilent:true}之后，将数据置为初始值，model.set将不触发change事件。同样的，属性安静的改变后，change:attribute事件将在下个change事件发生时调用。
	·介于vie.$(selector)现在等同于view.$el.find(selector)，而不是$(selector, view.el)，它将不再支持HTML字符串或者DOM元素作为selector参数。

Backbone Events
	Events是一个模块，可被嵌入任何对象中，为对象提供绑定自定义事件的能力。Eents不需要在使用前定义，可以传递参数。例：
	var object = {};
	_.extend(object, Backbone.Events);
	object.on("alert", function(msg){
		alert("Triggered" + msg);
	});
	object.trigger("alert", "an event");
	例如，这样可以为你的应用的不同部分提供便利的事件分发：var dispatcher = _.clone(Backbone.Events);

on	object.on(event, callback, [context])	Alias:bind
	绑定一个callback至一个对象。只要event被触发，将执行callback函数。如果你在一个页面有大量不同的事件，惯例是用冒号分割来命名："poll:start"，或者"change:selection"。还可以通过空格隔开，同时绑定多个事件：
	book.on("change:title change:author");
	要给this变量提供上下文环境context，通过给第三个可选参数：model.on("change", this.render, this)
	任何事件发生的时候，绑定的特殊的"all"事件都将会被触发，这时，触发的事件名称为第一个参数。例如，从一个对象中触发所有事件到另一个对象中去：
	proxy.on("all", function(eventName){
		object.trigger(eventName);
	});	

off	object.off([event], [callback], [context])  Alias: unbind
	从对象中移除先前绑定的callback函数。如果没有指定context，当前回调函数将在所有上下文中被移除。如果没有指定回调函数，当前event的所有回调函数将会被移除。如果没有指定events，改对象的所有events的回调函数将会被移除。
	//仅仅移除"onChange"回调函数
	object.off("change", onChange);
	//移除所有"change"回调函数
	object.off("change");
	//移除所有events的"onChange"回调函数
	object.off(null, onChange);
	//移除"context"下所有events的所有回调函数
	object.off(null, null, context);
	//移除object的所有回调函数
	object.off();

trigger	object.trigger(event, [*args])
	触发指定event的所有回调函数，或者由空格分隔的多项event。第二项参数将会传递给回调函数。
	
	
	
Backbone.Model
	Models是任何Javascript应用的核心，它包括交互数据，以及相应的大量逻辑：转换、验证、计算属性，以及访问控制。你在你自己的特定域中扩展Backbone.Model，Model将会为你提供一系列基础函数来管理变化。
	下面是一个虚构的例子，但它展示了定义model，包括：自定义函数、设定属性值、触发绑定在某个属性上的事件。在这段代码执行一次后，你的浏览器控制台中将可以获取到sidebar这个对象，你可以尝试一下。
	var Sidebar = Backbone.Model.extend({
		promptColor: function(){
			var cssColor = promp("Please enter a CSS color:");
			this.set({color: cssColor});
		}
	});
	window.sidebar = new Sidebar;
	sidebar.on("change:color", function(model, color){
		$("#sidebar").css({background: color});
	});
	sidebar.set({color: "white"});
	sidebar.prompColor();
	
Extend	Backbone.Model.extend(properties, [classProperties])
	要创建你自己的Model类，你只需要扩展Backbone.Model，提供实例属性，或者直接通过构造函数添加可选的类属性。
	extend将正确的设置原型链，所以由extend创建的子类随你喜欢的无限扩展。
	var Note = Backbone.Model.extend({
		initialize: function(){...}
		author: function(){...}
		coordinate: function(){...}
		allowedToEdit: function(account){
			return true;
		}
	});
	var PrivateNote = Note.extend({
		allowedToEdit: function(account){
			return account.owns(this);
		}
	});
	关于super的简要提示：JavaScript没有提供一个简单的调用父类的途径——与之同名的函数在原型链的顶端定义的。如果你重载了类似set，或者save的核心函数，而你想要调用父类的函数，你必须显示调用，如下：
	var Note = Backbone.Model.extend({
		set: function(attributes, options){
			Backbone.Model.protoype.set.call(this, attributes, options);
			...
		}
	});
	
constructor/initialize	new Model([attributes])
	实例化一个模型的时候，你可以通过attributes传递初始值，它将会被set到模型中。如果你定义了一个initialize方法，在生成模型的时候将会调用这个方法。
	new Book({
		title: "One Thousand and One Nights",
		author: "Scheheazade"
	});
	在少数情况下，如果你想尝试一下其它方法，你可以重载constructor方法，将会替换掉模型的实际的constructor方法。
	
get	mode.get(attribute)
	获取到模型属性的当前值。例如：note.get("title")。
	
set model.set(attributes, [options])
	设置模型的哈希属性（一个或多个）。如果任何属性改变了模型的状态，将会触发"change"事件，除非option中传递了一个{silent: true}。同样可以触发特定属性的change事件，你可以绑定它们：change:title，或者change:content。你同样可以单独传递键值：
	note.set({title:"March 10", content: "In his eyes she eclipses..."});
	book.set("title", "A Scandal in Bohemia");
	如果模型有一个validate方法，将会在属性设置之前验证属性，如果验证未通过，则不会改变，set方法将会返回false。否则，set方法会返回模型的引用。你同样可以在options中传递error回调函数，它将在验证失败触发"error"方法时被调用。如果传递了{silent:true}，则验证将延迟到下一次改变。
	
escape	model.escape(attribute)
	与set方法像似，但返回的的是模型属性的HTML-escaped版本。如果把模型中的属性插入到HTML中，使用escape方法将会避免XSS攻击
	var hackr = new Backbone.Model({
		name: "<script>alert('xss')</script>"
	});
	alert(hacker.escape('name'));
	
has	model.has(attribute)
	如果属性非null或者非undefined，将会返回true
	if (note.has("title")){
		...
	}
	
unset	model.unset(attribute, [options])
	从内部属性列表中通过删除，来移除一个属性。如果options中没有传递silent，将会触发"change"事件。
	
clear	model.clear([optioins])
	移除模型中的所有属性。如果options中没有传递silent，将会触发"change"事件。
	
id	model.id
	模型中的特殊属性，id可以是任意字符串(整数或者UUID)。如果你在属性列表中设置了id值，它将会拷贝一份作为模型的直接属性。collection中可以通过id来获取models，默认情况下，id被用来生成模型的URL。

idAttribute	model.idAttribute
	模型的唯一标识保存在id属性下。如果你直接与使用不同key的后端数据库（CouchDB，MongoDB）通信，你可能需要建立一个id到模型idAttribute的映射：
	var Meal = Backbone.Model.extend({
		idAttribute: "_id"
	});

cid	model.cid
	模型的一个特殊属性，cid或者client id是在模型第一次创建的时候自动生成的唯一标识。Client id使用非常便利，在模型还没有存储到后端还没有得到最终id，但需要在UI中显示的时候。Client id格式如下：c1, c2, c3...

attribute	model.attributes
	attributes属性包含了模型状态的内部列表。请用set方法来设置属性，而不是直接改变它。如果你需要获取到一份模型的属性，请使用toJSON方法。

changed	model.changed
	changes属性包含了最后一次触发"change"事件后所有属性的变化。请不要直接修改changed。它的状态由set和change方法维护。可以通过changedAttributes获取到changed的一份拷贝

defaults	model.defaults or model.defaults()
	defaults列表（或者方法）可以用来定义模型的默认值。创建模型实例的时候，任何一个未指定的属性都将被设置为默认值。
	var Meal = Backbone.Model.extend({
		defaults: {
			"appetizer": "caesar salad",
			"entree": "ravioli",
			"dessert": "cheesecake"
		}
	});
	alert("Dessert will be " + (new Meal).get('dessert'));
	提示：注意，JavaScript中，对象的传递是引用传递，所以，如果你在默认值中包含了一个对象，它将在所有实例中被共享。

toJson	model.toJSON()
	返回模型属性的JSON格式字符串。这可以用来持久化、序列化，或者在传给view之前增强。该方法的名字具有一定迷惑性，它并不返回JSON格式的字符串——恐怕这是JavaScript API中JSON.stringify所要做的事情。
	var artist = new Backbone.Model({
		firstName: "Wassily",
		lastName: "Kandinsky"
	});
	artist.set({birthday: "December 16, 1866"});
	alert(JSON.stringify(artist));

fetch model.fetch([options])
	通过调用Backbone.sync来重置模型的状态跟服务器保持一致。返回一个jqXHR。这在模型没有增加数据，或者你希望与最新的后台服务器中数据保持一致时，这非常有用。当服务器数据跟当前属性不一致时，将会触发"change"事件。option列表中接受success和error回调函数，回调函数以(model, response)作为参数。
	//channel模型每10秒从后台更新一次数据
	setInterval(function(){
		channel.fetch();
	}, 1000);
	
save	model.save([attributes], [options])
	保持模型到数据库（或者改变持久层），通过调用Backbone.sync。如果验证成功，返回jqXHR，否则返回false。attributes列表（和在set中一样）需要包含你希望更新的属性——keys不在其中的不会被改变——但是，资源的全部属性将会被传到后台。与set一样，你也可以不传递对象，而传递单独的key和value。如果模型有validate方法，而validate方法返回false，模型将不会被保持。如果模型isNew，save将会是一个"create"（HTTP POST），如果后台模型已经存在，save将会是一个"updata"（HTTP PUT）。
	在新属性上调用save方法，将会立即触发"change"事件，当服务器知道改变成功之后，触发"sync"事件。如果你希望在模型属性设置成功前等待服务器，可以传递{wait:true}。
	在接下来的例子中，注意到模型第一次save时，我们重载版本的Backbone.sync方法是怎样接收"create"方法，并在第二次调用时，是怎样接收"updata"方法的。
	Backbone.sync = function(method, model){
		alert(method + ": " + JSON.stringigy(model));
		model.id = 1;
	}
	var book = new Backbone.Model({
		title: "The Rough Riders",
		author: "Theodore Roosevelt"
	});
	book.save();
	book.save({author: "Teddy"});
	save方法接收options列表中success方法和error方法，其中参数为(model, response)。如果model有一个validate方法，且validate方法返回为fail，将会调用error回调函数。如果服务器端验证失败，将会在返回文本格式或者JSON格式的HTTP码-200。
	book.save("author", "F.D.R.", {error: function(){...}});

destroy	model.destroy([options])
	通过向Backbone.sync发起HTTP DELETE请求，销毁服务器端的模型。返回一个jqXHR对象，如果模型inNEW，则返回false。options列表接受success和error方法。触发一个“destroy”事件，将会冒泡至任何包含了这个模型的collections中去，当服务器端知道模型销毁成功时，还会触发“sync”事件。如果你希望等待服务器端将模型从collection中销毁，传递{wait:true}
	book.destroy({success: function(){
		...
	}});

validate	model.validate(attributes)
	该函数未定义，如果你需要在Javascript中使用，鼓励你在自定义的validate逻辑中重载它。validate函数在set和save方法执行之前调用，并从set和save方法中获取属性。如果属性验证通过，validate方法不返回任何值；否则，如果你愿意，将返回错误信息。它可以是简单到显示一个字符串格式的错误提示，也可以复杂到一个描述语法错误的错误提示对象。如果validate方法返回错误，将不执行set和save方法，而模型属性也不会被改变。验证失败，将触发“error”事件。
	var Charpter = Backbone.Model.extend({
		validate: function(attrs) {
			if (attrs.end < attrs.start) {
				return "can't end before it starts";
			}
		}
	});
	var one = new Chapter({
		title: "Chapter One: The Beginning"
	});
	one.on("error", function(model, error){
		alert(model.get("title") + " " + error);
	});
	one.set({
		start: 15,
		end: 10
	});
	在模型层和集合层提供粗粒度错误信息，“error”事件非常有用，但如果要在某一视图中更好的处理错误，你可能需要直接定义一个error回调函数来重载和覆盖它
	account.set({access: "unlimited"}, {
		error: function(){
			alert(error);
		}
	});

isValie	model.isValid()
	如果你静默改变模型数据，模型可能出于无效状态。如果在输入的时候处理将很有用。根据你的validate方法，调用model.isValid()方法来检查当前模型是否处于有效状态。

url	model.url()
	返回可能存在在服务器上的模型资源的相对路径。如果你的模型存在其它地方，用正确的逻辑来重载这个方法。生成如下格式的URL："/[collection.url][id]"，如果模型不是集合的一部分，将返回"/[urlRoot]/id"。
	由于要使用到Collection#url来生成URL，确保你定义过它，或者拥有一个urlRoot属性。如果所有模型公用一个公共的URL，也可以通过
	
	
	
	
	




	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
